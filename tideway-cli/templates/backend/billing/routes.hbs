//! Billing routes for Stripe integration.

use axum::{
    body::Bytes,
    extract::State,
    http::{HeaderMap, StatusCode},
    routing::{get, post},
    Json, Router,
};
{{#if has_organizations}}
use sea_orm::EntityTrait;
{{/if}}
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tideway::billing::{
    BillingStore, CheckoutManager, CheckoutRequest as TidewayCheckoutRequest, InvoiceManager,
    PlanStore, PortalManager, StoredPlan, WebhookHandler, WebhookOutcome,
    validate_plan, validate_plan_with_stripe, StripePriceValidator,
    BillingAuditEvent, BillingAuditLogger,
};
use tideway::Result;

{{#if has_organizations}}
use crate::entities::organization;
{{/if}}
use crate::error::BillingState;

/// Billing routes
pub fn billing_routes() -> Router<Arc<BillingState>> {
    Router::new()
        .route("/plans", get(list_plans))
        .route("/checkout", post(create_checkout))
        .route("/subscription", get(get_subscription))
        .route("/invoices", get(list_invoices))
        .route("/portal", post(create_portal))
        .route("/webhook", post(handle_webhook))
}

// Request/Response types

#[derive(Debug, Deserialize)]
pub struct CheckoutRequest {
    {{#if has_organizations}}
    pub organization_id: String,
    {{else}}
    pub user_id: String,
    {{/if}}
    pub success_url: String,
    pub cancel_url: String,
}

#[derive(Debug, Serialize)]
pub struct CheckoutResponse {
    pub checkout_url: String,
    pub session_id: String,
}

#[derive(Debug, Deserialize)]
pub struct SubscriptionRequest {
    {{#if has_organizations}}
    pub organization_id: String,
    {{else}}
    pub user_id: String,
    {{/if}}
}

#[derive(Debug, Serialize)]
pub struct SubscriptionResponse {
    pub has_subscription: bool,
    pub status: Option<String>,
    pub plan_id: Option<String>,
    pub trial_days_remaining: Option<u32>,
    pub cancel_at_period_end: bool,
}

#[derive(Debug, Deserialize)]
pub struct PortalRequest {
    {{#if has_organizations}}
    pub organization_id: String,
    {{else}}
    pub user_id: String,
    {{/if}}
    pub return_url: String,
}

#[derive(Debug, Serialize)]
pub struct PortalResponse {
    pub portal_url: String,
}

#[derive(Debug, Deserialize)]
pub struct InvoicesRequest {
    {{#if has_organizations}}
    pub organization_id: String,
    {{else}}
    pub user_id: String,
    {{/if}}
}

#[derive(Debug, Serialize)]
pub struct InvoiceResponse {
    pub id: String,
    pub status: String,
    pub amount_due: i64,
    pub amount_paid: i64,
    pub currency: String,
    pub created: u64,
    pub invoice_pdf: Option<String>,
    pub hosted_invoice_url: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct InvoicesListResponse {
    pub invoices: Vec<InvoiceResponse>,
}

#[derive(Debug, Serialize)]
pub struct PlanResponse {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub price_cents: i64,
    pub currency: String,
    pub interval: String,
    pub included_seats: u32,
    pub features: serde_json::Value,
    pub limits: serde_json::Value,
    pub trial_days: Option<u32>,
}

impl From<StoredPlan> for PlanResponse {
    fn from(plan: StoredPlan) -> Self {
        Self {
            id: plan.id,
            name: plan.name,
            description: plan.description,
            price_cents: plan.price_cents,
            currency: plan.currency,
            interval: plan.interval.as_str().to_string(),
            included_seats: plan.included_seats,
            features: plan.features,
            limits: plan.limits,
            trial_days: plan.trial_days,
        }
    }
}

#[derive(Debug, Serialize)]
pub struct PlansListResponse {
    pub plans: Vec<PlanResponse>,
}

// Handlers

/// List available plans (public endpoint for pricing pages).
async fn list_plans(
    State(state): State<Arc<BillingState>>,
) -> Result<Json<PlansListResponse>> {
    let plans = state.billing_store.list_plans().await?;
    let plans = plans.into_iter().map(PlanResponse::from).collect();
    Ok(Json(PlansListResponse { plans }))
}

async fn create_checkout(
    State(state): State<Arc<BillingState>>,
    Json(body): Json<CheckoutRequest>,
) -> Result<Json<CheckoutResponse>> {
    {{#if has_organizations}}
    let org = organization::Entity::find_by_id(&body.organization_id)
        .one(state.db.as_ref())
        .await
        .map_err(|e| tideway::TidewayError::Database(e.to_string()))?
        .ok_or_else(|| tideway::TidewayError::NotFound("Organization not found".to_string()))?;

    let checkout_manager = CheckoutManager::new(
        state.billing_store.clone(),
        state.stripe_client.clone(),
        state.plans.clone(),
        state.checkout_config.clone(),
    );

    let request = TidewayCheckoutRequest::new(
        "default",
        body.success_url,
        body.cancel_url,
    );

    let session = checkout_manager.create_checkout_session(&org, request).await?;
    {{else}}
    // For B2C, create a simple billable entity
    let billable = SimpleBillable {
        id: body.user_id.clone(),
        email: "".to_string(), // Would be fetched from user
    };

    let checkout_manager = CheckoutManager::new(
        state.billing_store.clone(),
        state.stripe_client.clone(),
        state.plans.clone(),
        state.checkout_config.clone(),
    );

    let request = TidewayCheckoutRequest::new(
        "default",
        body.success_url,
        body.cancel_url,
    );

    let session = checkout_manager.create_checkout_session(&billable, request).await?;
    {{/if}}

    Ok(Json(CheckoutResponse {
        checkout_url: session.url,
        session_id: session.id,
    }))
}

async fn get_subscription(
    State(state): State<Arc<BillingState>>,
    axum::extract::Query(params): axum::extract::Query<SubscriptionRequest>,
) -> Result<Json<SubscriptionResponse>> {
    {{#if has_organizations}}
    let billable_id = &params.organization_id;
    {{else}}
    let billable_id = &params.user_id;
    {{/if}}

    let subscription = state.billing_store
        .get_subscription(billable_id)
        .await?;

    match subscription {
        Some(sub) => {
            Ok(Json(SubscriptionResponse {
                has_subscription: true,
                status: Some(sub.status.as_str().to_string()),
                plan_id: Some(sub.plan_id.clone()),
                trial_days_remaining: sub.trial_days_remaining(),
                cancel_at_period_end: sub.cancel_at_period_end,
            }))
        }
        None => {
            Ok(Json(SubscriptionResponse {
                has_subscription: false,
                status: None,
                plan_id: None,
                trial_days_remaining: None,
                cancel_at_period_end: false,
            }))
        }
    }
}

async fn list_invoices(
    State(state): State<Arc<BillingState>>,
    axum::extract::Query(params): axum::extract::Query<InvoicesRequest>,
) -> Result<Json<InvoicesListResponse>> {
    {{#if has_organizations}}
    let billable_id = &params.organization_id;
    {{else}}
    let billable_id = &params.user_id;
    {{/if}}

    let invoice_manager = InvoiceManager::new(
        state.billing_store.clone(),
        state.stripe_client.clone(),
    );

    let invoice_list = invoice_manager
        .list_invoices(billable_id, Default::default())
        .await?;

    let invoices = invoice_list
        .invoices
        .into_iter()
        .map(|inv| InvoiceResponse {
            id: inv.id,
            status: inv.status.as_str().to_string(),
            amount_due: inv.amount_due,
            amount_paid: inv.amount_paid,
            currency: inv.currency,
            created: inv.created,
            invoice_pdf: inv.invoice_pdf,
            hosted_invoice_url: inv.hosted_invoice_url,
        })
        .collect();

    Ok(Json(InvoicesListResponse { invoices }))
}

async fn create_portal(
    State(state): State<Arc<BillingState>>,
    Json(body): Json<PortalRequest>,
) -> Result<Json<PortalResponse>> {
    {{#if has_organizations}}
    let _org = organization::Entity::find_by_id(&body.organization_id)
        .one(state.db.as_ref())
        .await
        .map_err(|e| tideway::TidewayError::Database(e.to_string()))?
        .ok_or_else(|| tideway::TidewayError::NotFound("Organization not found".to_string()))?;

    let billable_id = &body.organization_id;
    {{else}}
    let billable_id = &body.user_id;
    {{/if}}

    let portal_manager = PortalManager::new(
        state.billing_store.clone(),
        state.stripe_client.clone(),
        state.portal_config.clone(),
    );

    let session = portal_manager.create_portal_session(billable_id, &body.return_url).await?;

    Ok(Json(PortalResponse {
        portal_url: session.url,
    }))
}

async fn handle_webhook(
    State(state): State<Arc<BillingState>>,
    headers: HeaderMap,
    body: Bytes,
) -> std::result::Result<StatusCode, (StatusCode, String)> {
    let signature = headers
        .get("stripe-signature")
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| {
            (StatusCode::BAD_REQUEST, "Missing Stripe-Signature header".to_string())
        })?;

    let webhook_handler = WebhookHandler::new(
        state.billing_store.clone(),
        state.webhook_secret.clone(),
        state.plans.clone(),
    );

    let event = webhook_handler
        .verify_signature(&body, signature)
        .map_err(|e| {
            tracing::warn!(error = %e, "Webhook signature verification failed");
            (StatusCode::BAD_REQUEST, "Invalid signature".to_string())
        })?;

    tracing::info!(
        event_type = %event.event_type,
        event_id = %event.id,
        "Processing Stripe webhook"
    );

    match webhook_handler.handle_event(event).await {
        Ok(outcome) => {
            match outcome {
                WebhookOutcome::Processed => {
                    tracing::info!("Webhook processed successfully");
                }
                WebhookOutcome::AlreadyProcessed => {
                    tracing::info!("Webhook already processed");
                }
                WebhookOutcome::Ignored => {
                    tracing::debug!("Webhook ignored");
                }
            }
            Ok(StatusCode::OK)
        }
        Err(e) => {
            tracing::error!(error = %e, "Failed to process webhook");
            Err((StatusCode::INTERNAL_SERVER_ERROR, "Processing failed".to_string()))
        }
    }
}

{{#unless has_organizations}}
/// Simple billable entity for B2C billing.
struct SimpleBillable {
    id: String,
    email: String,
}

impl tideway::billing::BillableEntity for SimpleBillable {
    fn billable_id(&self) -> &str {
        &self.id
    }

    fn billable_type(&self) -> &str {
        "user"
    }

    fn email(&self) -> &str {
        &self.email
    }

    fn name(&self) -> Option<&str> {
        None
    }
}
{{/unless}}

// =============================================================================
// Admin Plan Management Routes
// =============================================================================

use axum::routing::{delete, put};
use tideway::billing::PlanInterval;

/// Admin plan management routes (requires admin authentication).
pub fn admin_plan_routes() -> Router<Arc<BillingState>> {
    Router::new()
        .route("/plans", get(admin_list_plans))
        .route("/plans", post(admin_create_plan))
        .route("/plans/{plan_id}", get(admin_get_plan))
        .route("/plans/{plan_id}", put(admin_update_plan))
        .route("/plans/{plan_id}", delete(admin_delete_plan))
        .route("/plans/{plan_id}/active", post(admin_set_plan_active))
}

// Admin Plan Request/Response Types

#[derive(Debug, Serialize)]
pub struct AdminPlanResponse {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub stripe_price_id: String,
    pub stripe_seat_price_id: Option<String>,
    pub price_cents: i64,
    pub currency: String,
    pub interval: String,
    pub included_seats: u32,
    pub features: serde_json::Value,
    pub limits: serde_json::Value,
    pub trial_days: Option<u32>,
    pub is_active: bool,
    pub sort_order: i32,
    pub created_at: u64,
    pub updated_at: u64,
}

impl From<StoredPlan> for AdminPlanResponse {
    fn from(plan: StoredPlan) -> Self {
        Self {
            id: plan.id,
            name: plan.name,
            description: plan.description,
            stripe_price_id: plan.stripe_price_id,
            stripe_seat_price_id: plan.stripe_seat_price_id,
            price_cents: plan.price_cents,
            currency: plan.currency,
            interval: plan.interval.as_str().to_string(),
            included_seats: plan.included_seats,
            features: plan.features,
            limits: plan.limits,
            trial_days: plan.trial_days,
            is_active: plan.is_active,
            sort_order: plan.sort_order,
            created_at: plan.created_at,
            updated_at: plan.updated_at,
        }
    }
}

#[derive(Debug, Serialize)]
pub struct AdminPlansListResponse {
    pub plans: Vec<AdminPlanResponse>,
}

#[derive(Debug, Deserialize)]
pub struct CreatePlanRequest {
    pub id: String,
    pub name: String,
    #[serde(default)]
    pub description: Option<String>,
    pub stripe_price_id: String,
    #[serde(default)]
    pub stripe_seat_price_id: Option<String>,
    pub price_cents: i64,
    #[serde(default = "default_currency")]
    pub currency: String,
    #[serde(default = "default_interval")]
    pub interval: String,
    #[serde(default = "default_included_seats")]
    pub included_seats: u32,
    #[serde(default = "default_features")]
    pub features: serde_json::Value,
    #[serde(default = "default_limits")]
    pub limits: serde_json::Value,
    #[serde(default)]
    pub trial_days: Option<u32>,
    #[serde(default = "default_is_active")]
    pub is_active: bool,
    #[serde(default)]
    pub sort_order: i32,
    /// If true, validate that the Stripe price ID exists before creating.
    #[serde(default)]
    pub validate_stripe: bool,
}

fn default_currency() -> String { "usd".to_string() }
fn default_interval() -> String { "monthly".to_string() }
fn default_included_seats() -> u32 { 1 }
fn default_features() -> serde_json::Value { serde_json::json!({}) }
fn default_limits() -> serde_json::Value { serde_json::json!({}) }
fn default_is_active() -> bool { true }

#[derive(Debug, Deserialize)]
pub struct UpdatePlanRequest {
    pub name: Option<String>,
    pub description: Option<String>,
    pub stripe_price_id: Option<String>,
    pub stripe_seat_price_id: Option<String>,
    pub price_cents: Option<i64>,
    pub currency: Option<String>,
    pub interval: Option<String>,
    pub included_seats: Option<u32>,
    pub features: Option<serde_json::Value>,
    pub limits: Option<serde_json::Value>,
    pub trial_days: Option<u32>,
    pub is_active: Option<bool>,
    pub sort_order: Option<i32>,
}

#[derive(Debug, Deserialize)]
pub struct SetPlanActiveRequest {
    pub is_active: bool,
}

// Admin Plan Handlers

/// List all plans (including inactive) for admin.
async fn admin_list_plans(
    State(state): State<Arc<BillingState>>,
) -> Result<Json<AdminPlansListResponse>> {
    let plans = state.billing_store.list_all_plans().await?;
    let plans = plans.into_iter().map(AdminPlanResponse::from).collect();
    Ok(Json(AdminPlansListResponse { plans }))
}

/// Get a single plan by ID.
async fn admin_get_plan(
    State(state): State<Arc<BillingState>>,
    axum::extract::Path(plan_id): axum::extract::Path<String>,
) -> Result<Json<AdminPlanResponse>> {
    let plan = state.billing_store
        .get_plan(&plan_id)
        .await?
        .ok_or_else(|| tideway::TidewayError::NotFound(format!("Plan '{}' not found", plan_id)))?;
    Ok(Json(AdminPlanResponse::from(plan)))
}

/// Create a new plan.
///
/// If `validate_stripe` is true in the request, validates that the Stripe price ID
/// exists and is active before creating the plan.
async fn admin_create_plan(
    State(state): State<Arc<BillingState>>,
    Json(body): Json<CreatePlanRequest>,
) -> Result<Json<AdminPlanResponse>> {
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0);

    let plan = StoredPlan {
        id: body.id,
        name: body.name,
        description: body.description,
        stripe_price_id: body.stripe_price_id,
        stripe_seat_price_id: body.stripe_seat_price_id,
        price_cents: body.price_cents,
        currency: body.currency,
        interval: PlanInterval::from_str(&body.interval),
        included_seats: body.included_seats,
        features: body.features,
        limits: body.limits,
        trial_days: body.trial_days,
        is_active: body.is_active,
        sort_order: body.sort_order,
        created_at: now,
        updated_at: now,
    };

    // Validate plan data (format, required fields, etc.)
    validate_plan(&plan)?;

    // Optionally validate against Stripe API
    if body.validate_stripe {
        validate_plan_with_stripe(&plan, state.stripe_client.as_ref()).await?;
    }

    state.billing_store.create_plan(&plan).await?;

    // Audit log
    state.audit_logger.log(BillingAuditEvent::PlanCreated {
        plan_id: plan.id.clone(),
        name: plan.name.clone(),
        admin_id: None, // TODO: Extract from auth context
    }).await;

    tracing::info!(plan_id = %plan.id, "Created billing plan");
    Ok(Json(AdminPlanResponse::from(plan)))
}

/// Update an existing plan.
async fn admin_update_plan(
    State(state): State<Arc<BillingState>>,
    axum::extract::Path(plan_id): axum::extract::Path<String>,
    Json(body): Json<UpdatePlanRequest>,
) -> Result<Json<AdminPlanResponse>> {
    let mut plan = state.billing_store
        .get_plan(&plan_id)
        .await?
        .ok_or_else(|| tideway::TidewayError::NotFound(format!("Plan '{}' not found", plan_id)))?;

    // Track changes for audit
    let mut changes = Vec::new();

    // Apply updates
    if let Some(name) = body.name {
        changes.push(format!("name: {} -> {}", plan.name, name));
        plan.name = name;
    }
    if let Some(desc) = body.description {
        changes.push("description".to_string());
        plan.description = Some(desc);
    }
    if let Some(price_id) = body.stripe_price_id {
        changes.push(format!("stripe_price_id: {} -> {}", plan.stripe_price_id, price_id));
        plan.stripe_price_id = price_id;
    }
    if let Some(seat_price_id) = body.stripe_seat_price_id {
        changes.push("stripe_seat_price_id".to_string());
        plan.stripe_seat_price_id = Some(seat_price_id);
    }
    if let Some(price) = body.price_cents {
        changes.push(format!("price_cents: {} -> {}", plan.price_cents, price));
        plan.price_cents = price;
    }
    if let Some(currency) = body.currency {
        changes.push(format!("currency: {} -> {}", plan.currency, currency));
        plan.currency = currency;
    }
    if let Some(interval) = body.interval {
        changes.push("interval".to_string());
        plan.interval = PlanInterval::from_str(&interval);
    }
    if let Some(seats) = body.included_seats {
        changes.push(format!("included_seats: {} -> {}", plan.included_seats, seats));
        plan.included_seats = seats;
    }
    if let Some(features) = body.features {
        changes.push("features".to_string());
        plan.features = features;
    }
    if let Some(limits) = body.limits {
        changes.push("limits".to_string());
        plan.limits = limits;
    }
    if let Some(trial) = body.trial_days {
        changes.push("trial_days".to_string());
        plan.trial_days = Some(trial);
    }
    if let Some(active) = body.is_active {
        changes.push(format!("is_active: {} -> {}", plan.is_active, active));
        plan.is_active = active;
    }
    if let Some(order) = body.sort_order {
        changes.push(format!("sort_order: {} -> {}", plan.sort_order, order));
        plan.sort_order = order;
    }

    plan.updated_at = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0);

    state.billing_store.update_plan(&plan).await?;

    // Audit log
    state.audit_logger.log(BillingAuditEvent::PlanUpdated {
        plan_id: plan.id.clone(),
        admin_id: None, // TODO: Extract from auth context
        changes,
    }).await;

    tracing::info!(plan_id = %plan.id, "Updated billing plan");
    Ok(Json(AdminPlanResponse::from(plan)))
}

/// Delete a plan.
///
/// This will fail if there are active subscriptions using this plan.
/// Consider using `set_plan_active(false)` to deactivate instead.
async fn admin_delete_plan(
    State(state): State<Arc<BillingState>>,
    axum::extract::Path(plan_id): axum::extract::Path<String>,
) -> Result<Json<tideway::MessageResponse>> {
    // Check plan exists
    let _ = state.billing_store
        .get_plan(&plan_id)
        .await?
        .ok_or_else(|| tideway::TidewayError::NotFound(format!("Plan '{}' not found", plan_id)))?;

    // Check for active subscriptions using this plan
    let subscription_count = state.billing_store
        .count_subscriptions_by_plan(&plan_id)
        .await?;

    if subscription_count > 0 {
        // Audit log the blocked deletion attempt
        state.audit_logger.log(BillingAuditEvent::PlanDeletionBlocked {
            plan_id: plan_id.clone(),
            subscription_count,
            admin_id: None, // TODO: Extract from auth context
        }).await;

        return Err(tideway::billing::BillingError::PlanHasActiveSubscriptions {
            plan_id: plan_id.clone(),
            subscription_count,
        }.into());
    }

    state.billing_store.delete_plan(&plan_id).await?;

    // Audit log
    state.audit_logger.log(BillingAuditEvent::PlanDeleted {
        plan_id: plan_id.clone(),
        admin_id: None, // TODO: Extract from auth context
    }).await;

    tracing::info!(plan_id = %plan_id, "Deleted billing plan");
    Ok(Json(tideway::MessageResponse::new("Plan deleted successfully")))
}

/// Set plan active/inactive status.
async fn admin_set_plan_active(
    State(state): State<Arc<BillingState>>,
    axum::extract::Path(plan_id): axum::extract::Path<String>,
    Json(body): Json<SetPlanActiveRequest>,
) -> Result<Json<AdminPlanResponse>> {
    // Check plan exists
    let _ = state.billing_store
        .get_plan(&plan_id)
        .await?
        .ok_or_else(|| tideway::TidewayError::NotFound(format!("Plan '{}' not found", plan_id)))?;

    state.billing_store.set_plan_active(&plan_id, body.is_active).await?;

    // Audit log
    if body.is_active {
        state.audit_logger.log(BillingAuditEvent::PlanActivated {
            plan_id: plan_id.clone(),
            admin_id: None, // TODO: Extract from auth context
        }).await;
    } else {
        state.audit_logger.log(BillingAuditEvent::PlanDeactivated {
            plan_id: plan_id.clone(),
            admin_id: None, // TODO: Extract from auth context
        }).await;
    }

    // Fetch updated plan
    let plan = state.billing_store.get_plan(&plan_id).await?.unwrap();

    tracing::info!(plan_id = %plan_id, is_active = body.is_active, "Updated plan active status");
    Ok(Json(AdminPlanResponse::from(plan)))
}
